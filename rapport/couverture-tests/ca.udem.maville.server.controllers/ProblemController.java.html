<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProblemController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">maVille</a> &gt; <a href="index.source.html" class="el_package">ca.udem.maville.server.controllers</a> &gt; <span class="el_source">ProblemController.java</span></div><h1>ProblemController.java</h1><pre class="source lang-java linenums">package ca.udem.maville.server.controllers;

import ca.udem.maville.hooks.UseRequest;
import ca.udem.maville.server.dao.files.ProblemDAO;
import ca.udem.maville.server.models.FicheProbleme;
import ca.udem.maville.utils.RequestType;
import ca.udem.maville.utils.SimilarityUtil;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.javalin.http.Context;

import io.javalin.json.JavalinJackson;
import org.bson.types.ObjectId;
import org.slf4j.Logger;

import java.util.ArrayList;
import java.util.List;


/**
 * La controller qui gère les différentes interactions du client avec le serveur
 * en tout ce qui concerne les fiches problèmes.
 */
public class ProblemController {

    public String urlHead;
    public Logger logger;


<span class="fc" id="L30">    public ProblemController(String urlHead, Logger logger) {</span>
<span class="fc" id="L31">        this.urlHead = urlHead;</span>
<span class="fc" id="L32">        this.logger = logger;</span>
<span class="fc" id="L33">    }</span>

    /**
     * Cette route permet de récupérer tous les problèmes présents dans la base de
     * données et qui ne sont pas encore traités.
     * @param ctx qui représente le contexte de la requête.
     */
    public void getAll(Context ctx) {
        try {

<span class="fc" id="L43">            List&lt;FicheProbleme&gt; problems = ProblemDAO.findAll();</span>

            // Renvoyer les fiches problèmes trouvées
<span class="nc" id="L46">            ctx.status(200).json(problems).contentType(&quot;application/json&quot;);</span>
<span class="fc" id="L47">        } catch (Exception e) {</span>
<span class="fc" id="L48">            e.printStackTrace();</span>
<span class="fc" id="L49">            ctx.status(500).result(&quot;{\&quot;message\&quot;: \&quot;Une erreur est interne survenue! Veuillez réessayer plus tard.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L50">        }</span>
<span class="fc" id="L51">    }</span>

    /**
     * Cette route permet de créer une nouvelle fiche problème pour un signalement déclaré.
     * Le body doit contenir toutes informations nécessaires notamment :
     * - typeTravaux: qui représente le type travail requis sous forme Label
     * - quartier: qui représente le quartier affecté. Il est sous forme Label
     * - localisation: ici on s'intéressera principalement à la rue ou à l'adresse du résident
     * - description: la description du problème rencontré
     * - priorite: la priorité accordée au problème par le STPM.
     * - signalements: Les ids des signalements liés à la fiche problème
     * - residents: les ids des résidents ayant déclarés le problème. Très important.
     * Elle s'occupe automatiquement d'assigner les champs id et statut.
     * Elle inclut de marquer tous les signalements comme traités, ce qui envoie des notifications aux résidents.
     * Elle inclut aussi l'envoi d'une notification à tous les prestataires pouvant être intéressés.
     * qui pourraient être intéressés par le problème.
     * @param ctx représente le contexte de la requête.
     */
    public void create(Context ctx) {
        try {
            // Récupérer les informations sur le nouveau problème
<span class="nc" id="L72">            FicheProbleme newProblem = ctx.bodyAsClass(FicheProbleme.class);</span>

            // S'assurer que le statut est le bon avant de sauvegarder
<span class="nc" id="L75">            newProblem.setStatut(&quot;en attente&quot;);</span>
<span class="nc" id="L76">            ProblemDAO.save(newProblem);</span>

<span class="nc" id="L78">            ObjectMapper mapper = JavalinJackson.defaultMapper();</span>

            // Marquer les signalements comme traités.
<span class="nc" id="L81">            List&lt;ObjectId&gt; signalements = newProblem.getSignalements();</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">            for(ObjectId id : signalements) {</span>
<span class="nc" id="L83">                String response = UseRequest.sendRequest(urlHead + &quot;/signalement/markAsProcessed/&quot; + id.toHexString() + &quot;?treated=false&quot;, RequestType.PATCH, null);</span>
<span class="nc" id="L84">                JsonNode json = mapper.readTree(response);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                if(json.get(&quot;status&quot;).asInt() != 200) {</span>
<span class="nc" id="L86">                    JsonNode data = json.get(&quot;data&quot;);</span>
<span class="nc" id="L87">                    logger.error(data.get(&quot;message&quot;).asText());</span>
                }
<span class="nc" id="L89">            }</span>

            // Envoyer des notifications aux prestataires intéressés.
<span class="nc" id="L92">            String quartier = newProblem.getQuartier().replace(&quot; &quot;, &quot;+&quot;);</span>
<span class="nc" id="L93">            String type = newProblem.getTypeTravaux().replace(&quot; &quot;, &quot;+&quot;);</span>

<span class="nc" id="L95">            String response = UseRequest.sendRequest(urlHead + &quot;/prestataire/getConcerned?quartier=&quot; + quartier + &quot;&amp;type=&quot; + type, RequestType.GET, null);</span>
<span class="nc" id="L96">            JsonNode json = mapper.readTree(response);</span>
<span class="nc" id="L97">            JsonNode data = json.get(&quot;data&quot;);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            if(json.get(&quot;status&quot;).asInt() != 200) {</span>
<span class="nc" id="L99">                throw new Exception(data.get(&quot;message&quot;).asText());</span>
            }

<span class="nc bnc" id="L102" title="All 2 branches missed.">            if(!data.isArray()) {</span>
<span class="nc" id="L103">                throw new Exception(&quot;Les prestataires intéressés n'est pas un tableau.&quot;);</span>
            }

<span class="nc bnc" id="L106" title="All 2 branches missed.">            for(JsonNode element : data) {</span>
<span class="nc" id="L107">                String id = element.asText();</span>
<span class="nc" id="L108">                String body = &quot;{&quot; +</span>
                        &quot;\&quot;message\&quot;: \&quot;Une nouvelle fiche problème qui pourrait vous intéresser a été créée.\&quot;,&quot; +
                        &quot;\&quot;user\&quot;: \&quot;&quot; + id + &quot;\&quot;,&quot; +
<span class="nc" id="L111">                        &quot;\&quot;url\&quot;: \&quot;/prestataire/probleme/&quot; + newProblem.getId() + &quot;\&quot;&quot; +</span>
                        &quot;}&quot;;
<span class="nc" id="L113">                String response1 = UseRequest.sendRequest(urlHead + &quot;/notification&quot;, RequestType.POST, body);</span>

<span class="nc" id="L115">                JsonNode json1 = mapper.readTree(response1);</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">                if(json1.get(&quot;status&quot;).asInt() != 201) {</span>
<span class="nc" id="L118">                    JsonNode info = json1.get(&quot;data&quot;);</span>
<span class="nc" id="L119">                    logger.error(info.get(&quot;message&quot;).asText());</span>
                }
<span class="nc" id="L121">            }</span>

            // Renvoyer la fiche problème pour marquer le succès
<span class="nc" id="L124">            ctx.status(201).json(newProblem).contentType(&quot;application/json&quot;);</span>

<span class="fc" id="L126">        } catch (Exception e) {</span>
<span class="fc" id="L127">            e.printStackTrace();</span>
<span class="fc" id="L128">            ctx.status(500).result(&quot;{\&quot;message\&quot;: \&quot;Une erreur est interne survenue! Veuillez réessayer plus tard.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L129">        }</span>
<span class="fc" id="L130">    }</span>

    /**
     * Cette route permet de récupérer une fiche problème en particulier à
     * partir de son id.
     * @param ctx représente le contexte de la requête.
     */
    public void getById(Context ctx) {
        try {
<span class="fc" id="L139">            String id = ctx.pathParam(&quot;id&quot;);</span>

<span class="fc" id="L141">            FicheProbleme probleme = ProblemDAO.findById(new ObjectId(id));</span>

<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (probleme == null) {</span>
<span class="fc" id="L144">                ctx.status(404).result(&quot;{\&quot;message\&quot;: \&quot;Aucune fiche problème avec un tel ID retrouvée.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="fc" id="L145">                return;</span>
            }

            // Renvoyer la fiche problème
<span class="nc" id="L149">            ctx.status(200).json(probleme).contentType(&quot;application/json&quot;);</span>

<span class="nc" id="L151">        } catch (Exception e) {</span>
<span class="nc" id="L152">            e.printStackTrace();</span>
<span class="nc" id="L153">            ctx.status(500).result(&quot;{\&quot;message\&quot;: \&quot;Une erreur est interne survenue! Veuillez réessayer plus tard.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L154">        }</span>
<span class="nc" id="L155">    }</span>

    /**
     * Cette route permet de récupérer toutes les fiches problèmes qui sont dans un quartier
     * particulier et ont un type particulier de problème qu'elles traitent.
     * Elle nécessite deux query parameters :
     * - quartier : le quartier ciblé
     * - type : le type de travail nécessaire
     * Le body de la requête doit contenir la description du signalement.
     * @param ctx qui représente le contexte de la requête
     */
    public void getSimilar(Context ctx) {
        try {
<span class="nc" id="L168">            String quartier = ctx.queryParam(&quot;quartier&quot;);</span>
<span class="nc" id="L169">            String type = ctx.queryParam(&quot;type&quot;);</span>

<span class="nc bnc" id="L171" title="All 8 branches missed.">            if(quartier == null || type == null || quartier.isEmpty() || type.isEmpty()) {</span>
<span class="nc" id="L172">                ctx.status(400).result(&quot;{\&quot;message\&quot;: \&quot;Les query parameters quartier et type sont requis.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L173">                return;</span>
            }

<span class="nc" id="L176">            List&lt;FicheProbleme&gt; found = ProblemDAO.findSimilar(quartier, type);</span>

<span class="nc" id="L178">            JsonNode json = JavalinJackson.defaultMapper().readTree(ctx.body());</span>

<span class="nc" id="L180">            String description = json.get(&quot;description&quot;).asText();</span>

            // Faire le filtrage de similarité directement ici
<span class="nc" id="L183">            ArrayList&lt;FicheProbleme&gt; similar = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L185" title="All 2 branches missed.">            for(FicheProbleme probleme : found) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                if(SimilarityUtil.isSimilar(description, probleme.getDescription(), 0.2)) {</span>
<span class="nc" id="L187">                    similar.add(probleme);</span>
                }
<span class="nc" id="L189">            }</span>

<span class="nc" id="L191">            ctx.status(200).json(similar).contentType(&quot;application/json&quot;);</span>

<span class="nc" id="L193">        } catch(Exception e) {</span>
<span class="nc" id="L194">            e.printStackTrace();</span>
<span class="nc" id="L195">            ctx.status(500).result(&quot;{\&quot;message\&quot;: \&quot;Une erreur est interne survenue! Veuillez réessayer plus tard.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L196">        }</span>
<span class="nc" id="L197">    }</span>

    /**
     * Cette méthode permet d'ajouter un résident à la liste des résidents du problème
     * et un signalement à la liste des signalement du problème.
     * Utile lorsqu'un problème à déjà été créé pour un signalement.
     * Le body doit contenir les champs:
     * - resident qui représente l'id du résident ayant fait le nouveau signalement
     * - signalement qui représente l'id de son signalement.
     * Elle inclut de marquer le signalement comme traité, ce qui envoie une notification au résident.
     * @param ctx qui représente le contexte de la requête.
     */
    public void addExisting(Context ctx) {
        try {
<span class="nc" id="L211">            String id = ctx.pathParam(&quot;id&quot;);</span>

<span class="nc" id="L213">            FicheProbleme probleme = ProblemDAO.findById(new ObjectId(id));</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (probleme == null) {</span>
<span class="nc" id="L216">                ctx.status(404).result(&quot;{\&quot;message\&quot;: \&quot;Aucune fiche problème avec un tel ID retrouvée.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L217">                return;</span>
            }

<span class="nc" id="L220">            ObjectMapper mapper = JavalinJackson.defaultMapper();</span>
<span class="nc" id="L221">            JsonNode json = mapper.readTree(ctx.body());</span>

<span class="nc bnc" id="L223" title="All 4 branches missed.">            if(!json.has(&quot;resident&quot;) || !json.has(&quot;signalement&quot;)) {</span>
<span class="nc" id="L224">                ctx.status(400).result(&quot;{\&quot;message\&quot;: \&quot;Les champs resident et signalement sont obligatoires.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L225">                return;</span>
            }

<span class="nc" id="L228">            List&lt;ObjectId&gt; signalements = probleme.getSignalements();</span>
<span class="nc" id="L229">            signalements.add(new ObjectId(json.get(&quot;signalement&quot;).asText()));</span>
<span class="nc" id="L230">            probleme.setSignalements(signalements);</span>

<span class="nc" id="L232">            List&lt;ObjectId&gt; residents = probleme.getResidents();</span>
<span class="nc" id="L233">            residents.add(new ObjectId(json.get(&quot;resident&quot;).asText()));</span>
<span class="nc" id="L234">            probleme.setResidents(residents);</span>

<span class="nc" id="L236">            ProblemDAO.save(probleme);</span>

            // Marquer le signalement comme traité.
<span class="nc" id="L239">            String response1 = UseRequest.sendRequest(urlHead + &quot;/signalement/markAsProcessed/&quot; + json.get(&quot;signalement&quot;).asText() + &quot;?treated=true&quot;, RequestType.PATCH, null);</span>
<span class="nc" id="L240">            JsonNode json1 = mapper.readTree(response1);</span>
<span class="nc" id="L241">            JsonNode data1 = json.get(&quot;data&quot;);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if(json1.get(&quot;status&quot;).asInt() != 200) {</span>
<span class="nc" id="L243">                throw new Exception(data1.get(&quot;message&quot;).asText());</span>
            }

<span class="nc" id="L246">            ctx.status(200).json(probleme).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L247">        } catch (Exception e) {</span>
<span class="nc" id="L248">            e.printStackTrace();</span>
<span class="nc" id="L249">            ctx.status(500).result(&quot;{\&quot;message\&quot;: \&quot;Une erreur est interne survenue! Veuillez réessayer plus tard.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L250">        }</span>
<span class="nc" id="L251">    }</span>

    /**
     * Cette route permet de récupérer les id de tous ceux qui ont déclarés le problème.
     * @param ctx qui représente le contexte de la requête.
     */
    public void getReporters(Context ctx) {
        try {
<span class="nc" id="L259">            String id = ctx.pathParam(&quot;id&quot;);</span>

<span class="nc" id="L261">            FicheProbleme problem = ProblemDAO.findById(new ObjectId(id));</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">            if(problem == null) {</span>
<span class="nc" id="L264">                ctx.status(404).result(&quot;{\&quot;message\&quot;: \&quot;Aucune fiche problème avec un tel ID trouvée.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L265">                return;</span>
            }

<span class="nc" id="L268">            List&lt;ObjectId&gt; reporters = problem.getResidents();</span>
<span class="nc" id="L269">            List&lt;String&gt; reportersIds = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L271" title="All 2 branches missed.">            for(ObjectId userId : reporters) {</span>
<span class="nc" id="L272">                reportersIds.add(userId.toHexString());</span>
<span class="nc" id="L273">            }</span>

<span class="nc" id="L275">            ctx.status(200).json(reportersIds).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L276">        } catch (Exception e) {</span>
<span class="nc" id="L277">            e.printStackTrace();</span>
<span class="nc" id="L278">            ctx.status(500).result(&quot;{\&quot;message\&quot;: \&quot;Une erreur est interne survenue! Veuillez réessayer plus tard.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L279">        }</span>
<span class="nc" id="L280">    }</span>

    /**
     * Cette route permet de marquer une fiche problème comme traitée.
     * @param ctx qui représente le contexte de la requête.
     */
    public void markAsProcessed(Context ctx) {
        try {
<span class="nc" id="L288">            String id = ctx.pathParam(&quot;id&quot;);</span>

<span class="nc" id="L290">            FicheProbleme problem = ProblemDAO.findById(new ObjectId(id));</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">            if(problem == null) {</span>
<span class="nc" id="L293">                ctx.status(404).result(&quot;{\&quot;message\&quot;: \&quot;Aucune fiche problème avec un tel ID trouvée.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L294">                return;</span>
            }

<span class="nc" id="L297">            problem.setStatut(&quot;traitée&quot;);</span>
<span class="nc" id="L298">            ProblemDAO.save(problem);</span>

            // Renvoyer la réponse de succès
<span class="nc" id="L301">            ctx.status(200).json(problem).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L302">        } catch (Exception e) {</span>
<span class="nc" id="L303">            e.printStackTrace();</span>
<span class="nc" id="L304">            ctx.status(500).result(&quot;{\&quot;message\&quot;: \&quot;Une erreur est interne survenue! Veuillez réessayer plus tard.\&quot;}&quot;).contentType(&quot;application/json&quot;);</span>
<span class="nc" id="L305">        }</span>
<span class="nc" id="L306">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>