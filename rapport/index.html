<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Rapport IFT2255</title>

    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
    <img src="images/udem_logo.png" alt="Université de Montréal" style="width: 10rem;">
    <hr>

    <h1>Rapport du projet MaVille</h1>

    <section id="cadre">
    <h2>Mise à jour du projet</h2>


    <div class="placeholder">
        <h4>Cadre</h4>
        <p>
            Ce projet est dans le cadre du Cours IFT2255 - elle vise la conception et implantation des logiciels.
            Il s’agit ici du deuxième jalon, qui nous amène à concrétiser nos réflexions précédentes en développant une première version fonctionnelle de l’application MaVille. 
            L’objectif principal est de mettre en pratique les notions vues en cours comme l’analyse des besoins, la modélisation et la conception orientée objet  à travers une application en ligne de commande. 
            En plus du développement, nous devons produire un rapport HTML structuré et maintenir notre travail sur GitHub tout au long du processus.
        </p>

        <h4>Contexte</h4>
        <p>
            La Ville de Montréal est régulièrement confrontée à de nombreux travaux publics et privés qui affectent la circulation et la qualité de vie des résidents. 
            Les outils actuellement disponibles pour s’informer sur ces travaux, comme le service Info-Entraves, sont jugés insuffisants par les citoyens, qui se retrouvent souvent mal informés, ce qui génère un sentiment d’imprévisibilité et de frustration.
            Le Service des Travaux Publics de Montréal (STPM) souhaite donc une solution plus efficace pour assurer une meilleure communication entre les citoyens, les prestataires et la Ville. L’application MaVille répond à ce besoin en proposant plusieurs fonctionnalités comme:
        </p>
        <ul>
            <li>Consultation des travaux en cours ou planifiés.</li>
            <li>Réception de notifications ciblées.</li>
            <li>Signalement de problèmes routiers.</li>
            <li>Candidature à des projets de résolution de problèmes par les prestataires.</li>
            <li>Suivi et gestion des projets par le STPM.</li>
        </ul>
        <p>
            L’application doit aussi intégrer une API ouverte de la Ville pour récupérer les données réelles des chantiers.
        </p>

        <h4>Repartition du travail</h4>
        <section id="glossaire">
        <dl class="glossaire">
            <dt>Cyreanne</dt>
            <dd>Architecture et choix de conception + Rapport et Git</dd>

            <dt>Lallia</dt>
            <dd>Implémentation + test unitaire (en collaboration avec Josué)</dd>

            <dt>Roxanne</dt>
            <dd>Diagramme de Classe bas niveau</dd>

            <dt>Zachary</dt>
            <dd>Diagramme de séquence</dd>

            <dt>Josué</dt>
            <dd>Implémentation + test unitaire (en collaboration avec Lallia)</dd>
        </dl>

        <h4>Corrections</h4>
        <p>Les cas d'utilisation, le diagramme de cas d'utilisations, le diagramme d'activité et le diagramme de classes ont été adaptés pour intégrer les nouvelles exigences et les remarques du DM précédent.</p>
    </section>

    </div>
    </section>

    <section id="Architecture">
        <h3>Architecture</h3>
        <div class="placeholder">
            <p>
                MaVille suit le style d'architecture en couches pour pouvoir garantir une séparation claire entre les responsabilités et avoir une maintenabilité qui est meilleure <br>
                Elle intègre aussi une architecture REST et une API fourni par la ville.
            </p>
            <ul>
                <li>Couche client gérant l'interaction avec l'utilisateur.</li>
                <li>Couche server contenant la logique fonctionnelle.</li>
                <li>Couche d'accés aux données se chargeant de l'initialisation et du stockage des données.</li>
            </ul>
    
            <h4>Utilisateurs et leurs moyens de communiquer avec l'application</h4>
            <ul>
                <li>Résident : peuvent consulter les travaux, faire des signalements et gérer les notifications.</li>
                <li>Prestataire : peuvent soumenttre des projets de travaux, mettre à jour les informations sur le déroulement des travaux.</li>
                <li>Agent de la STPM : peuvent valider ou rejetter les demandes pour les projets, affecte des prioritês aux problèmes signalés.
                    Dans notre implémentation, il est représenté par le serveur qui réalise ces processus de manière automatique et aléatoire.
                </li>
            </ul>

            <h4>Composants liées au style d'architecture</h4>

            <ul>
                <li>Couche client : affiche les menus, capte les entrées utilisateurs et redirige vers les bons cas d'utilisation</li>
                <li>Couche métier : traite les cas d'utilisation comme le signalement, les notifications etc...</li>
                <li>Couche d'accès aux données : gère les entités comme les travaux, les projets, les problèmes, les utilisateurs dans des fichiers ou dans une base de données</li>
            </ul>
            
            <h4>Composants additionnelles jouant un rôle clé</h4>
            <ul>
                <li>
                    Le composant UseRequest dans le package hooks permet de faciliter la communication entre le server et le client en
                    centralisant la logique de requête HTTP etd e réception des réponses.
                </li>
            </ul>

            <h4>Espace de stockage ou base de données</h4>
            <p>L'application stocke :</p>
            <ul>
                <li>Les utilisateurs, les projets, les signalements et les problèmes etc...</li>
            </ul>

            <h4>Services externes ou API</h4>
            <p>On va intégrer l'application à l'API de la ville, qui fournit déjà des données sur les travaux en cours.</p>

            <img src="images/Architecture.png" alt="Architecture">
        </div>
    </section>
    

    <section id="DiagrammeAct">
        <h3>Diagramme des processus métier mise à jour</h3>
        <div class="placeholder">
            <img src="images/Diagramme_activite.jpg" alt="diagramme d'activités">
        </div>
    </section>

    <section id="DiagrammeClasse">
        <h3>Diagramme du domaine métier mise à jour</h3>
        <div class="placeholder">
            <img src="images/MaVille.png" alt="diagramme de classe">
        </div>
    </section>

    <section id="DiagrammeSequence">
        <h3>Diagrammes de séquence du Cas d'utilisation Signaler un problème Routier</h3>
        <div class="placeholder">
            <img src="images/Diagramme_sequence-Signaler_probleme_routier.jpg" alt="diagramme de séquence 1">
        </div>
        <h3>Diagrammes de séquence du Cas d'utilisation Consulter les notifications</h3>
        <div class="placeholder">
            <img src="images/Diagramme_sequence-Signaler_probleme_routier.jpg" alt="diagramme de séquence 2">
        </div>
    </section>

    <section id="BesoinsFunct">
        <h3>Diagramme de cas d'utilisation mise à jour</h3>
        <div class="placeholder">
            <img src="images/img_diagramme_cas_utilisations.png" alt="diagramme de CU">
        </div>
    </section>

    <section id="Choix design">
        <h3>Justification du choix du design</h3>
        <div class="placeholder">
            <p>
                L'architecture choisie, comme dit plus haut, est une architecture en couches qui représente aussi une architecture REST. 
                <br>La logique a été de séparer complètement les tâches dans l'application pour permettre une meilleur cohésion.
                <br>Nous avons trois packages principaux dans l'application. 
                <br>Le premier est le package client. Il contient la classe MaVille et les classes Utilisateur, Prestataire, Resident, Notification, Projet, Signalement, FicheProbleme et Candidature. 
                <br>La classe MaVille est celle avec laquelle le client (en Ligne de commande) communique. Elle lui affiche des prompts, recueille ses choix et ses entrées puis communique avec le reste de l'application pour chercher et lui renvoyer les informations dont il a besoin. 
                <br>Ainsi, elle communique avec les autres classes du packages qui représentent chacune une entité de l'application (l'utilisateur, la fiche problème, un signalement, une candidature, etc.). Ces classes communiquent à leur tour avec le backend grâce aux deuxième package.
                <br>Le deuxième package est le package hooks. Il contient juste la classe UseRequest qui représente une abstraction de la logique d'envoi et de réception de requêtes HTTP à une API. 
                <br>Cette classe est conçue pour centraliser cette logique et permettre un envoi et une réception facile des données à travers toutes l'application. Elle fait donc le pont entre la partie client et le package server.
                <br>Le troisième package est le package server. Il contient la classe Server, la Database et les controllers. Le Server, est un serveur Javalin. C'est lui qui intercepte, traite et redirige les requêtes client. 
                <br>La classe Database comme son nom l'indique est l'endroit où on initialise les données à partir de l'API de Montréal et où on stocke les données de l'application entière. Elle contient en réalité une Map pour stocker chaque type d'entité. 
                <br>En effet, pour chaque entité de l'application, il existe un Controller qui est chargé de s'occuper de tout ce qui la concerne. 
                <br>Chaque Controller communique avec la base de données en impactant uniquement la Map qui le concerne. Cette division de la logique permet de réduire le couplage parce que en cas de bugs et de problème lors d'une procédure, on sait exactement à quel Controller s'adresser et ça facilite le debugging. 
                <br>Ainsi, grâce à l'architecture en couches, la logique est répartie de manière à permettre une plus forte cohésion tout au long de l'application à travers la répartition des modules. 
                <br>Et à travers l'architecture REST, on a un moyen plus efficace et plus centralisé de communication, ce qui réduit les relations d'interdépendances entre les classes et qui permet donc un faible couplage. Cela facilite aussi de nouvelles intégrations et des améliorations à l'application.
            </p>
        </div>
    </section>
</div>
<footer>
    <p>&copy; 2025 BugBusters. Tous droits réservés.</p>
    <p>DM2 IFT2255 - UdeM</p>
</footer>
</body>
</html>
